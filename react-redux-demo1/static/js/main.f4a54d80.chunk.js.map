{"version":3,"sources":["reducers/postsReducer.js","reducers/index.js","actions/types.js","store.js","components/Posts.js","actions/postActions.js","components/postForm.js","App.js","serviceWorker.js","index.js"],"names":["initialState","items","item","rootReducer","combineReducers","posts","state","action","type","payload","middleware","thunk","store","createStore","compose","applyMiddleware","window","__REDUX_DEVTOOLS_EXTENSION__","Posts","this","props","fetchPost","nextProps","nextContext","newPost","post","unshift","postsItem","map","key","id","title","body","Component","connect","dispatch","fetch","headers","then","res","json","postForm","onChange","e","setState","target","name","value","onSubmit","preventDefault","creatPost","postData","method","JSON","stringify","console","log","App","className","Boolean","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.f4a54d80.chunk.js","sourcesContent":["/**\r\n * reducer作用返回新状态\r\n * reducer接受两个参数分别是action和当前的state然后返回一个新的state\r\n *  */\r\n// 引入需要types中的类型并返回最新状态\r\nimport { FETCH_POSTS, CREAT_POST } from '../actions/types'\r\n\r\nlet initialState = {\r\n    // 存储你想要获取的状态\r\n    items: [],\r\n    item: {}\r\n}\r\n\r\nexport default function (state = initialState, action) {\r\n    switch (action.type) {\r\n        // 判断postAction.js传过来的有没有FETCH_POSTS这个属性如果有就返回一个新的state\r\n        case FETCH_POSTS:\r\n            return {\r\n                ...state,\r\n                items: action.payload,//把从postActions.js接收到的数据返回到组件上\r\n            };\r\n        case CREAT_POST:\r\n            return {\r\n                ...state,\r\n                item: action.payload\r\n            }\r\n\r\n        default:\r\n            return state;\r\n    }\r\n\r\n}","//引入 reducer合成\r\nimport { combineReducers } from 'redux'\r\n// 引入一个需要用到reducer的js文件\r\nimport postsReducer from './postsReducer'\r\n// 在大的reducer中会对以下的reducer合成一个,再进行拆分\r\nconst rootReducer = combineReducers({\r\n   posts: postsReducer,//自定义\r\n})\r\nexport default rootReducer;","export const FETCH_POSTS = 'FETCH_POSTS'\r\nexport const CREAT_POST = 'CREAT_POST'\r\n","//创建一个 Redux store 来以存放应用中所有的 state。\r\n// compose用于后台调试\r\nimport { createStore, applyMiddleware,compose } from 'redux'\r\nimport thunk from 'redux-thunk'\r\n// 拆分redUcer\r\nimport rootReducer from './reducers/index'\r\n/**\r\n * createStore接收三个参数,reducer (一个或多个),状态,applyMiddleware(中间件)\r\n *  []reducer 作用收到action以后必须给出一个新的state,这样view才会发生变化,这种state的计算过程就叫做reducer\r\n * initialState初始空对象,使用的时候会返回新状态,依次执行\r\n * applyMiddleware将所有中间件组成一个数组\r\n * middleware来自thunk处理异步,异步执行开发的action\r\n *  */\r\nconst initialState = {}//初始空对象,使用的时候会返回新状态\r\nconst middleware = [thunk]\r\n// 把之前的[]替换成rootRoducer\r\nexport const store = createStore(\r\n    rootReducer,\r\n    initialState,\r\n    // 中间件\r\n    compose(\r\n        applyMiddleware(...middleware),\r\n        // 调试\r\n        window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__()\r\n    ),\r\n    )","// 请求数据\r\nimport React, { Component } from 'react'\r\n// 验证数据类型\r\nimport PropTypes from 'prop-types'\r\n// 引入关联的actions/postActions\r\nimport { fetchPost } from '../actions/postActions'\r\n// 引入connect 用于从ui组件生成容器组件,意思将两种组件连起来(将postActions和posts.js文件进行连接)\r\nimport { connect } from 'react-redux'\r\nclass Posts extends Component {\r\n    /**\r\n     * 当我们所有的数据都从reducer中取的话就可以不需要constructor\r\n     * 如果想要获取到从reducer(postsReducer.js)中返回的数据的话就需要用到mapStateToProps()\r\n     */\r\n    // constructor(props) {\r\n    //     super(props)\r\n    //     this.state = {\r\n    //         posts: []\r\n    //     }\r\n    // }\r\n    componentDidMount() {//页面渲染完成\r\n        // 调用connect传过来的fetchPost方法\r\n        this.props.fetchPost()\r\n    };\r\n    // 模块更新,它会在Component接受到新的状态(Props)时被触发\r\n    componentWillReceiveProps(nextProps, nextContext) {\r\n        // console.log(nextProps);\r\n        // console.log(nextContext);\r\n        // 提取提交过来的值并添加到post中渲染\r\n        if (nextProps.newPost) {\r\n            this.props.post.unshift(nextProps.newPost)\r\n\r\n        }\r\n    }\r\n    render() {\r\n        // console.log(this.props);\r\n\r\n        // 遍历posts \r\n        const postsItem = this.props.post.map(post => (\r\n            <div key={post.id}>\r\n                <h1>{post.title}</h1>\r\n                <p>{post.body}</p>\r\n            </div>\r\n        ))\r\n        return (\r\n            <div>\r\n                {postsItem}\r\n            </div>\r\n        )\r\n    }\r\n}\r\n// 定义验证的数据类型\r\nPosts.propTypes = {\r\n    // 验证fetchPost必须传来的是一个函数\r\n    fetchPost: PropTypes.func.isRequired,\r\n    post: PropTypes.array.isRequired\r\n\r\n}\r\n// 用mapStateToProps 状态转化成我们的属性\r\n/**\r\n     *  state.posts为在reducers/index.js中定义的\r\n     * state.posts.posts为reducers/postsReducer.js中定义的\r\n     */\r\n\r\nconst mapStateToProps = state => ({\r\n    post: state.posts.items,\r\n    // 获取提交的值\r\n    newPost: state.posts.item\r\n})\r\n\r\n// 使用connect连接这样才能用到reducer\r\nexport default connect(mapStateToProps, { fetchPost })(Posts);","// 引入定义的type类型\r\nimport { FETCH_POSTS, CREAT_POST } from './types'\r\n\r\n// 声明一个方法\r\nexport const fetchPost = () => (dispatch) => {\r\n    // 分发操作\r\n    fetch('http://jsonplaceholder.typicode.com/posts', {\r\n        headers: {\r\n            'content-type': 'application/json',\r\n            // 自动将http的不安全请求升级为https不然在github线上会报\r\n            \"Content-Security-Policy\": \"upgrade-insecure-requests\"\r\n        },\r\n    })\r\n        .then(res => res.json()).then(posts => {\r\n            dispatch({\r\n                // 一定要有一个type,属性名是定义\r\n                type: FETCH_POSTS,//dispatch触发store,store会拿到前一个状态返回给到reducer会根据传过来的type返回一个状态\r\n                payload: posts,//把接收的数据返回到postsReducer.js\r\n            })\r\n        })\r\n\r\n}\r\n// 点击添加按钮保存值\r\nexport const creatPost = (postData) => (dispatch) => {\r\n    fetch('http://jsonplaceholder.typicode.com/posts', {\r\n        method: 'POST',\r\n        headers: {\r\n            'content-type': 'application/json',\r\n            // 自动将http的不安全请求升级为https不然在github线上会报\r\n            \"Content-Security-Policy\": \"upgrade-insecure-requests\"\r\n        },\r\n        body: JSON.stringify(postData)\r\n    })\r\n        .then(res => res.json()).then(post => {\r\n            console.log(post);\r\n\r\n            // 数据存储到状态 \r\n            dispatch({\r\n                type: CREAT_POST,\r\n                payload: post,\r\n            })\r\n        })\r\n}\r\n","import React, { Component } from 'react'\r\n// 验证数据类型\r\nimport PropTypes from 'prop-types'\r\n// 引入关联的actions/postActions\r\nimport { creatPost } from '../actions/postActions'\r\n// 引入connect 用于从ui组件生成容器组件,意思将两种组件连起来(将postActions和posts.js文件进行连接)\r\nimport { connect } from 'react-redux'\r\nclass postForm extends Component {\r\n    constructor(props) {\r\n        super(props)\r\n        this.state = {\r\n            title: '',\r\n            body: ''\r\n        }\r\n    }\r\n    onChange = (e) => {\r\n        /**\r\n         * 赋值\r\n         */\r\n        this.setState({ [e.target.name]: e.target.value })\r\n\r\n    }\r\n    onSubmit = (e) => {\r\n        e.preventDefault()\r\n        const post = {\r\n            title: this.state.title,\r\n            body: this.state.body\r\n        }\r\n        //点击保存后触发action\r\n        this.props.creatPost(post)\r\n        // 因为生命周期的问题 ,在这里是拿不到值,应该在componentWillReceiveProps()方法中拿,渲染组件是posts.js可以写在posts页面\r\n        // console.log(this.props.item);\r\n    }\r\n    render() {\r\n        return (\r\n            <div>\r\n                <h1>添加内容</h1>\r\n                <form onSubmit={this.onSubmit}>\r\n                    <div>\r\n                        <label>\r\n                            title\r\n                        </label>\r\n                        <br />\r\n                        <input type=\"text\" name=\"title\" onChange={this.onChange} value={this.state.title}></input>\r\n                    </div>\r\n                    <div>\r\n                        <label>\r\n                            body\r\n                        </label>\r\n                        <br />\r\n                        <textarea name=\"body\" onChange={this.onChange} value={this.state.body}></textarea>\r\n                    </div>\r\n                    <br />\r\n                    <button type=\"submit\"> 添加</button>\r\n                </form>\r\n            </div>\r\n        )\r\n    }\r\n}\r\npostForm.propTypes = {\r\n    creatPost: PropTypes.func.isRequired,\r\n    \r\n}\r\nconst mapStateToProps = state => ({\r\n    item: state.posts.item\r\n})\r\nexport default connect(mapStateToProps, { creatPost })(postForm)","import React from 'react';\nimport './App.css';\n// Provider组件的出现是作为中间件降低各组件与Store之间的耦合。\nimport { Provider } from 'react-redux'\nimport { store } from './store'\nimport Posts from './components/Posts'\nimport PostForm from './components/postForm'\n\nfunction App() {\n  return (\n    // 全局使用redux\n    <Provider store={store}>\n      <div className=\"App\">\n        <PostForm />\n        <Posts />\n\n      </div>\n    </Provider>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}